{
  "version": 3,
  "sources": ["../../blaze-slider/dist/blaze-slider.esm.js"],
  "sourcesContent": ["/* blaze-slider v1.9.3 by Manan Tank */\n/**\n * calculate pages and return\n */\nfunction calculatePages(slider) {\n    const { slidesToShow, slidesToScroll, loop } = slider.config;\n    const { isStatic, totalSlides } = slider;\n    const pages = [];\n    const lastIndex = totalSlides - 1;\n    // start with index 0, keep adding slidesToScroll to get the new page\n    for (let startIndex = 0; startIndex < totalSlides; startIndex += slidesToScroll) {\n        const _endIndex = startIndex + slidesToShow - 1;\n        const overflow = _endIndex > lastIndex;\n        if (overflow) {\n            // if not looped\n            if (!loop) {\n                // adjust the startIndex\n                const startIndex = lastIndex - slidesToShow + 1;\n                const lastPageIndex = pages.length - 1;\n                // create page only if adjusting the startIndex does not make it the same as previously saved page\n                if (pages.length === 0 ||\n                    (pages.length > 0 && pages[lastPageIndex][0] !== startIndex)) {\n                    pages.push([startIndex, lastIndex]);\n                }\n                break;\n            }\n            // if looped\n            else {\n                // adjust the endIndex\n                const endIndex = _endIndex - totalSlides;\n                pages.push([startIndex, endIndex]);\n            }\n        }\n        else {\n            pages.push([startIndex, _endIndex]);\n        }\n        // if static, only allow 1 iteration\n        if (isStatic) {\n            break;\n        }\n    }\n    return pages;\n}\n\n/**\n * calculate all possible states of given slider\n */\nfunction calculateStates(slider) {\n    const { totalSlides } = slider;\n    const { loop } = slider.config;\n    // get all possible pages\n    const pages = calculatePages(slider);\n    const states = [];\n    const lastPageIndex = pages.length - 1;\n    for (let pageIndex = 0; pageIndex < pages.length; pageIndex++) {\n        // calculate prev and next page index based on config\n        let nextPageIndex, prevPageIndex;\n        if (loop) {\n            nextPageIndex = pageIndex === lastPageIndex ? 0 : pageIndex + 1;\n            prevPageIndex = pageIndex === 0 ? lastPageIndex : pageIndex - 1;\n        }\n        else {\n            nextPageIndex =\n                pageIndex === lastPageIndex ? lastPageIndex : pageIndex + 1;\n            prevPageIndex = pageIndex === 0 ? 0 : pageIndex - 1;\n        }\n        const currentPageStartIndex = pages[pageIndex][0];\n        const nextPageStartIndex = pages[nextPageIndex][0];\n        const prevPageStartIndex = pages[prevPageIndex][0];\n        // calculate slides that need to be moved for transitioning to next and prev state from current state\n        let nextDiff = nextPageStartIndex - currentPageStartIndex;\n        if (nextPageStartIndex < currentPageStartIndex) {\n            nextDiff += totalSlides;\n        }\n        let prevDiff = currentPageStartIndex - prevPageStartIndex;\n        if (prevPageStartIndex > currentPageStartIndex) {\n            prevDiff += totalSlides;\n        }\n        states.push({\n            page: pages[pageIndex],\n            next: {\n                stateIndex: nextPageIndex,\n                moveSlides: nextDiff,\n            },\n            prev: {\n                stateIndex: prevPageIndex,\n                moveSlides: prevDiff,\n            },\n        });\n    }\n    return states;\n}\n\nconst START = 'start';\nconst END = 'end';\nconst DEV = process.env.NODE_ENV !== 'production';\n\n/**\n * it fixes below scenarios which are wrong (and adds a warning in console in development)\n * - config.slidesToShow greater than totalSlides\n * - config.slidesToScroll greater than config.slidesToShow which skips showing certain slides\n * - config.slidesToScroll too high such that it causes glitches\n */\nfunction fixSliderConfig(slider) {\n    const { slidesToScroll, slidesToShow } = slider.config;\n    const { totalSlides, config } = slider;\n    if (totalSlides < slidesToShow) {\n        if (DEV) {\n            console.warn('slidesToShow can not be larger than number of slides. Setting slidesToShow = totalSlides instead.');\n        }\n        config.slidesToShow = totalSlides;\n    }\n    if (totalSlides <= slidesToShow) {\n        // return because slidesToScroll does not need to be checked\n        return;\n    }\n    // detect slider skipping\n    if (slidesToScroll > slidesToShow) {\n        if (DEV) {\n            console.warn('slidesToScroll can not be greater than slidesToShow. Setting slidesToScroll = slidesToShow instead');\n        }\n        config.slidesToScroll = slidesToShow;\n    }\n    // detect slider jumping glitch\n    if (totalSlides < slidesToScroll + slidesToShow) {\n        const properSlidesToScroll = totalSlides - slidesToShow;\n        if (DEV) {\n            console.warn(`slidesToScroll = ${slidesToScroll} is too large for a slider with ${totalSlides} slides with slidesToShow=${slidesToShow}, setting max possible slidesToScroll = ${properSlidesToScroll} instead.`);\n        }\n        config.slidesToScroll = properSlidesToScroll;\n    }\n}\n\nclass Automata {\n    constructor(totalSlides, config) {\n        this.config = config;\n        this.totalSlides = totalSlides;\n        this.isTransitioning = false;\n        constructAutomata(this, totalSlides, config);\n    }\n    next(pages = 1) {\n        if (this.isTransitioning || this.isStatic)\n            return;\n        const { stateIndex } = this;\n        let slidesMoved = 0;\n        let newStateIndex = stateIndex;\n        for (let i = 0; i < pages; i++) {\n            const state = this.states[newStateIndex];\n            slidesMoved += state.next.moveSlides;\n            newStateIndex = state.next.stateIndex;\n        }\n        if (newStateIndex === stateIndex)\n            return;\n        this.stateIndex = newStateIndex;\n        return [stateIndex, slidesMoved];\n    }\n    prev(pages = 1) {\n        if (this.isTransitioning || this.isStatic)\n            return;\n        const { stateIndex } = this;\n        let slidesMoved = 0;\n        let newStateIndex = stateIndex;\n        for (let i = 0; i < pages; i++) {\n            const state = this.states[newStateIndex];\n            slidesMoved += state.prev.moveSlides;\n            newStateIndex = state.prev.stateIndex;\n        }\n        if (newStateIndex === stateIndex)\n            return;\n        this.stateIndex = newStateIndex;\n        return [stateIndex, slidesMoved];\n    }\n}\n// this will be called when slider is refreshed\nfunction constructAutomata(automata, totalSlides, config) {\n    automata.stateIndex = 0;\n    fixSliderConfig(automata);\n    automata.isStatic = totalSlides <= config.slidesToShow;\n    automata.states = calculateStates(automata);\n}\n\nfunction scrollPrev(slider, slideCount) {\n    const rAf = requestAnimationFrame;\n    if (!slider.config.loop) {\n        noLoopScroll(slider);\n    }\n    else {\n        // shift elements and apply negative transform to make it look like nothing changed\n        // disable transition\n        disableTransition(slider);\n        // apply negative transform\n        slider.offset = -1 * slideCount;\n        updateTransform(slider);\n        // and move the elements\n        wrapPrev(slider, slideCount);\n        const reset = () => {\n            rAf(() => {\n                enableTransition(slider);\n                rAf(() => {\n                    slider.offset = 0;\n                    updateTransform(slider);\n                    onSlideEnd(slider);\n                });\n            });\n        };\n        // if the scroll was done as part of dragging\n        // reset should be done after the dragging is completed\n        if (slider.isDragging) {\n            if (isTouch()) {\n                slider.track.addEventListener('touchend', reset, { once: true });\n            }\n            else {\n                slider.track.addEventListener('pointerup', reset, { once: true });\n            }\n        }\n        else {\n            rAf(reset);\n        }\n    }\n}\n// <--- move slider to left for showing content on right\nfunction scrollNext(slider, slideCount) {\n    const rAf = requestAnimationFrame;\n    if (!slider.config.loop) {\n        noLoopScroll(slider);\n    }\n    else {\n        // apply offset and let the slider scroll from  <- (right to left)\n        slider.offset = -1 * slideCount;\n        updateTransform(slider);\n        // once the transition is done\n        setTimeout(() => {\n            // remove the elements from start that are no longer visible and put them at the end\n            wrapNext(slider, slideCount);\n            disableTransition(slider);\n            // apply transform where the slider should go\n            slider.offset = 0;\n            updateTransform(slider);\n            rAf(() => {\n                rAf(() => {\n                    enableTransition(slider);\n                    onSlideEnd(slider);\n                });\n            });\n        }, slider.config.transitionDuration);\n    }\n}\nfunction onSlideEnd(slider) {\n    if (slider.onSlideCbs) {\n        const state = slider.states[slider.stateIndex];\n        const [firstSlideIndex, lastSlideIndex] = state.page;\n        slider.onSlideCbs.forEach((cb) => cb(slider.stateIndex, firstSlideIndex, lastSlideIndex));\n    }\n}\n\n// when loop is disabled, we must update the offset\nfunction noLoopScroll(slider) {\n    slider.offset = -1 * slider.states[slider.stateIndex].page[0];\n    updateTransform(slider);\n    onSlideEnd(slider);\n}\nfunction wrapPrev(slider, count) {\n    const len = slider.slides.length;\n    for (let i = 0; i < count; i++) {\n        // pick the last and move to first\n        const slide = slider.slides[len - 1];\n        // @ts-ignore\n        slider.track.prepend(slide);\n    }\n}\nfunction wrapNext(slider, count) {\n    for (let i = 0; i < count; i++) {\n        slider.track.append(slider.slides[0]);\n    }\n}\nfunction updateTransform(slider) {\n    const { track, offset, dragged } = slider;\n    if (offset === 0) {\n        track.style.transform = `translate3d(${dragged}px,0px,0px)`;\n    }\n    else {\n        track.style.transform = `translate3d(  calc( ${dragged}px + ${offset} * (var(--slide-width) + ${slider.config.slideGap})),0px,0px)`;\n    }\n}\nfunction enableTransition(slider) {\n    slider.track.style.transitionDuration = `${slider.config.transitionDuration}ms`;\n}\nfunction disableTransition(slider) {\n    slider.track.style.transitionDuration = `0ms`;\n}\n\nconst slideThreshold = 10;\nconst isTouch = () => 'ontouchstart' in window;\nfunction handlePointerDown(downEvent) {\n    const track = this;\n    const slider = track.slider;\n    if (slider.isTransitioning)\n        return;\n    slider.dragged = 0;\n    track.isScrolled = false;\n    track.startMouseClientX =\n        'touches' in downEvent ? downEvent.touches[0].clientX : downEvent.clientX;\n    if (!('touches' in downEvent)) {\n        // do not directly setPointerCapture on track - it blocks the click events\n        // https://github.com/GoogleChromeLabs/pointer-tracker/issues/4\n        const el = (downEvent.target || track);\n        el.setPointerCapture(downEvent.pointerId);\n    }\n    disableTransition(slider);\n    updateEventListener(track, 'addEventListener');\n}\nfunction handlePointerMove(moveEvent) {\n    const track = this;\n    const x = 'touches' in moveEvent ? moveEvent.touches[0].clientX : moveEvent.clientX;\n    const dragged = (track.slider.dragged = x - track.startMouseClientX);\n    const draggedAbs = Math.abs(dragged);\n    // consider dragging only if the user has dragged more than 5px\n    if (draggedAbs > 5) {\n        // track.setAttribute('data-dragging', 'true')\n        track.slider.isDragging = true;\n    }\n    // prevent vertical scrolling if horizontal scrolling is happening\n    if (draggedAbs > 15) {\n        moveEvent.preventDefault();\n    }\n    track.slider.dragged = dragged;\n    updateTransform(track.slider);\n    if (!track.isScrolled && track.slider.config.loop) {\n        if (dragged > slideThreshold) {\n            track.isScrolled = true;\n            track.slider.prev();\n        }\n    }\n}\nfunction handlePointerUp() {\n    const track = this;\n    const dragged = track.slider.dragged;\n    track.slider.isDragging = false;\n    updateEventListener(track, 'removeEventListener');\n    // reset drag\n    track.slider.dragged = 0;\n    updateTransform(track.slider);\n    enableTransition(track.slider);\n    if (!track.isScrolled) {\n        if (dragged < -1 * slideThreshold) {\n            track.slider.next();\n        }\n        else if (dragged > slideThreshold) {\n            track.slider.prev();\n        }\n    }\n}\nconst preventDefault = (event) => event.preventDefault();\n/**\n * drag based navigation for slider\n */\nfunction dragSupport(slider) {\n    // @ts-expect-error\n    const track = slider.track;\n    track.slider = slider;\n    const event = isTouch() ? 'touchstart' : 'pointerdown';\n    // @ts-expect-error\n    track.addEventListener(event, handlePointerDown);\n    // prevent click default when slider is being dragged or transitioning\n    track.addEventListener('click', (event) => {\n        if (slider.isTransitioning || slider.isDragging) {\n            event.preventDefault();\n            event.stopImmediatePropagation();\n            event.stopPropagation();\n        }\n    }, {\n        capture: true,\n    });\n    // prevent dragging of elements inside the slider\n    track.addEventListener('dragstart', preventDefault);\n}\nfunction updateEventListener(track, method) {\n    track[method]('contextmenu', handlePointerUp);\n    if (isTouch()) {\n        track[method]('touchend', handlePointerUp);\n        // @ts-expect-error\n        track[method]('touchmove', handlePointerMove);\n    }\n    else {\n        track[method]('pointerup', handlePointerUp);\n        // @ts-expect-error\n        track[method]('pointermove', handlePointerMove);\n    }\n}\n\nfunction handleAutoplay(slider) {\n    const config = slider.config;\n    if (!config.enableAutoplay)\n        return;\n    const dir = config.autoplayDirection === 'to left' ? 'next' : 'prev';\n    slider.autoplayTimer = setInterval(() => {\n        slider[dir]();\n    }, config.autoplayInterval);\n    if (config.stopAutoplayOnInteraction) {\n        slider.el.addEventListener(isTouch() ? 'touchstart' : 'mousedown', () => {\n            clearInterval(slider.autoplayTimer);\n        }, { once: true });\n    }\n}\n\nconst defaultConfig = {\n    // layout\n    slideGap: '20px',\n    slidesToScroll: 1,\n    slidesToShow: 1,\n    // behavior\n    loop: true,\n    // autoplay\n    enableAutoplay: false,\n    stopAutoplayOnInteraction: true,\n    autoplayInterval: 3000,\n    autoplayDirection: 'to left',\n    // pagination\n    enablePagination: true,\n    // transition\n    transitionDuration: 300,\n    transitionTimingFunction: 'ease',\n    draggable: true,\n};\nfunction createConfig(blazeConfig) {\n    // start with default config clone\n    const config = { ...defaultConfig };\n    for (const media in blazeConfig) {\n        // if the media matches, override the config with media config\n        if (window.matchMedia(media).matches) {\n            const mediaConfig = blazeConfig[media];\n            for (const key in mediaConfig) {\n                // @ts-expect-error\n                config[key] = mediaConfig[key];\n            }\n        }\n    }\n    return config;\n}\n\nfunction handleNavigation(slider) {\n    const prev = slider.el.querySelector('.blaze-prev');\n    const next = slider.el.querySelector('.blaze-next');\n    if (prev) {\n        prev.onclick = () => {\n            slider.prev();\n        };\n    }\n    if (next) {\n        next.onclick = () => {\n            slider.next();\n        };\n    }\n}\n\nfunction handlePagination(slider) {\n    if (!slider.config.enablePagination || slider.isStatic)\n        return;\n    const paginationContainer = slider.el.querySelector('.blaze-pagination');\n    if (!paginationContainer)\n        return;\n    slider.paginationButtons = [];\n    const total = slider.states.length;\n    for (let index = 0; index < total; index++) {\n        const button = document.createElement('button');\n        slider.paginationButtons.push(button);\n        button.textContent = 1 + index + '';\n        button.ariaLabel = `${index + 1} of ${total}`;\n        paginationContainer.append(button);\n        // @ts-expect-error\n        button.slider = slider;\n        // @ts-expect-error\n        button.index = index;\n        // @ts-expect-error\n        button.onclick = handlePaginationButtonClick;\n    }\n    // initially the first button is active\n    slider.paginationButtons[0].classList.add('active');\n}\nfunction handlePaginationButtonClick() {\n    const index = this.index;\n    const slider = this.slider;\n    const stateIndex = slider.stateIndex;\n    const loop = slider.config.loop;\n    const diff = Math.abs(index - stateIndex);\n    const inverseDiff = slider.states.length - diff;\n    const isDiffLargerThanHalf = diff > slider.states.length / 2;\n    const scrollOpposite = isDiffLargerThanHalf && loop;\n    // if target state is ahead of current state\n    if (index > stateIndex) {\n        // but the diff is too large\n        if (scrollOpposite) {\n            // scroll in opposite direction to reduce scrolling\n            slider.prev(inverseDiff);\n        }\n        else {\n            // scroll normally\n            slider.next(diff);\n        }\n    }\n    // if target state is before current state\n    else {\n        // but the diff is too large\n        if (scrollOpposite) {\n            // scroll in opposite direction\n            slider.next(inverseDiff);\n        }\n        else {\n            // scroll normally\n            slider.prev(diff);\n        }\n    }\n}\n\nfunction isTransitioning(slider, time = slider.config.transitionDuration) {\n    slider.isTransitioning = true;\n    setTimeout(() => {\n        slider.isTransitioning = false;\n    }, time);\n}\nclass BlazeSlider extends Automata {\n    constructor(blazeSliderEl, blazeConfig) {\n        const track = blazeSliderEl.querySelector('.blaze-track');\n        const slides = track.children;\n        const config = blazeConfig\n            ? createConfig(blazeConfig)\n            : { ...defaultConfig };\n        super(slides.length, config);\n        this.config = config;\n        this.el = blazeSliderEl;\n        this.track = track;\n        this.slides = slides;\n        this.offset = 0;\n        this.dragged = 0;\n        this.isDragging = false;\n        // @ts-ignore - for debugging\n        this.el.blazeSlider = this;\n        this.passedConfig = blazeConfig;\n        const slider = this;\n        track.slider = slider;\n        construct(config, slider);\n        // throttled to refresh every 200ms when resizing\n        let ignoreResize = false;\n        let width = 0;\n        window.addEventListener('resize', () => {\n            if (width === 0) {\n                width = window.innerWidth;\n                return;\n            }\n            const newWidth = window.innerWidth;\n            // ignore height change - only refresh if the width is changed\n            if (width === newWidth)\n                return;\n            width = newWidth;\n            if (!ignoreResize) {\n                ignoreResize = true;\n                setTimeout(() => {\n                    slider.refresh();\n                    ignoreResize = false;\n                }, 200);\n            }\n        });\n    }\n    next(count) {\n        if (this.isTransitioning)\n            return;\n        const transition = super.next(count);\n        if (!transition) {\n            isTransitioning(this);\n            return;\n        }\n        const [prevStateIndex, slideCount] = transition;\n        handleStateChange(this, prevStateIndex);\n        isTransitioning(this);\n        scrollNext(this, slideCount);\n    }\n    prev(count) {\n        if (this.isTransitioning)\n            return;\n        const transition = super.prev(count);\n        if (!transition) {\n            isTransitioning(this);\n            return;\n        }\n        const [prevStateIndex, slideCount] = transition;\n        handleStateChange(this, prevStateIndex);\n        isTransitioning(this);\n        scrollPrev(this, slideCount);\n    }\n    stopAutoplay() {\n        clearInterval(this.autoplayTimer);\n    }\n    destroy() {\n        // remove side effects that won't be overridden by construct()\n        // remove old drag event handler\n        this.track.removeEventListener(isTouch() ? 'touchstart' : 'pointerdown', \n        // @ts-expect-error\n        handlePointerDown);\n        // stop autoplay\n        this.stopAutoplay();\n        // remove pagination buttons\n        this.paginationButtons?.forEach((button) => button.remove());\n        // remove classes\n        this.el.classList.remove('static');\n        this.el.classList.remove(START);\n    }\n    refresh() {\n        const newConfig = this.passedConfig\n            ? createConfig(this.passedConfig)\n            : { ...defaultConfig };\n        this.destroy();\n        construct(newConfig, this);\n    }\n    /**\n     * Subscribe for slide change event\n     * Returns a function to unsubscribe from slide change event\n     */\n    onSlide(cb) {\n        if (!this.onSlideCbs)\n            this.onSlideCbs = new Set();\n        this.onSlideCbs.add(cb);\n        return () => this.onSlideCbs.delete(cb);\n    }\n}\nfunction handleStateChange(slider, prevStateIndex) {\n    const classList = slider.el.classList;\n    const stateIndex = slider.stateIndex;\n    const buttons = slider.paginationButtons;\n    if (!slider.config.loop) {\n        if (stateIndex === 0) {\n            classList.add(START);\n        }\n        else {\n            classList.remove(START);\n        }\n        if (stateIndex === slider.states.length - 1) {\n            classList.add(END);\n        }\n        else {\n            classList.remove(END);\n        }\n    }\n    if (buttons && slider.config.enablePagination) {\n        buttons[prevStateIndex].classList.remove('active');\n        buttons[stateIndex].classList.add('active');\n    }\n}\nfunction construct(config, slider) {\n    const track = slider.track;\n    slider.slides = track.children;\n    slider.offset = 0;\n    slider.config = config;\n    constructAutomata(slider, slider.totalSlides, config);\n    // if a side effect is in condition - make sure to add it for both conditions - so it gets cleaned up\n    // when refresh is called\n    if (!config.loop) {\n        slider.el.classList.add(START);\n    }\n    if (config.enableAutoplay && !config.loop) {\n        if (DEV) {\n            console.warn('enableAutoplay:true is not consistent with loop:false, auto-fixing with enableAutoplay:false');\n        }\n        config.enableAutoplay = false;\n    }\n    track.style.transitionProperty = 'transform';\n    track.style.transitionTimingFunction = slider.config.transitionTimingFunction;\n    track.style.transitionDuration = `${slider.config.transitionDuration}ms`;\n    const { slidesToShow, slideGap } = slider.config;\n    slider.el.style.setProperty('--slides-to-show', slidesToShow + '');\n    slider.el.style.setProperty('--slide-gap', slideGap);\n    if (!slider.isStatic) {\n        if (config.draggable) {\n            dragSupport(slider);\n        }\n    }\n    else {\n        slider.el.classList.add('static');\n    }\n    handlePagination(slider);\n    handleAutoplay(slider);\n    handleNavigation(slider);\n    updateTransform(slider);\n}\n\nexport { BlazeSlider as default };\n"],
  "mappings": "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",
  "names": ["startIndex", "event"]
}
